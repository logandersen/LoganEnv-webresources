"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
const dataverse_service_1 = require("../dataverse.service");
const node_1 = require("dataverse-webapi/lib/node");
const logger_1 = require("../logger");
const fs_1 = __importDefault(require("fs"));
function getWebResourceType(type) {
    switch (type) {
        case 'HTML':
            return 1;
        case 'CSS':
            return 2;
        case 'JavaScript':
            return 3;
        case 'XML':
            return 4;
        case 'PNG':
            return 5;
        case 'JPG':
            return 6;
        case 'GIF':
            return 7;
        case 'XAP':
            return 8;
        case 'XSL':
            return 9;
        case 'ICO':
            return 10;
        case 'SVG':
            return 11;
        case 'RESX':
            return 12;
        default:
            return 0;
    }
}
async function deploy(webResources, apiConfig, solution, files) {
    const publishXml = [];
    let resources = webResources;
    // Use list of files if provided
    if (files) {
        resources = [];
        for (const file of files.split(',')) {
            const resource = webResources.filter(r => r.path?.endsWith(file));
            if (resource.length === 0) {
                logger_1.logger.warn(`web resource ${file} not found in dataverse.config.json`);
                continue;
            }
            resources.push(resource[0]);
        }
    }
    const promises = resources.map(async (resource) => {
        let resourceId = '';
        try {
            resourceId = await retrieveResource(resource.name, apiConfig);
        }
        catch (error) {
            logger_1.logger.error(`failed to retrieve resource ${resource.name}: ${error.message}`);
            return;
        }
        const fileContent = await fs_1.default.promises.readFile(resource.path, 'utf8');
        const content = Buffer.from(fileContent).toString('base64');
        if (resourceId != '') {
            try {
                const updated = await updateResource(resourceId, resource, content, apiConfig);
                publishXml.push(updated);
            }
            catch (error) {
                logger_1.logger.error(`failed to update resource: ${error.message}`);
            }
        }
        else {
            try {
                resourceId = await createResource(resource, content, apiConfig);
            }
            catch (error) {
                logger_1.logger.error(`failed to create resource: ${error.message}`);
            }
            if (solution != undefined) {
                try {
                    await (0, dataverse_service_1.addToSolution)(resourceId, solution, dataverse_service_1.ComponentType.WebResource, apiConfig);
                }
                catch (error) {
                    logger_1.logger.error(`failed to add to solution: ${error.message}`);
                }
            }
        }
    });
    await Promise.all(promises);
    // publish resources
    if (publishXml.length > 0) {
        try {
            await (0, dataverse_service_1.publish)(publishXml.join(''), apiConfig);
        }
        catch (error) {
            logger_1.logger.error(error.message);
        }
    }
}
exports.deploy = deploy;
async function retrieveResource(name, apiConfig) {
    const options = `$select=webresourceid&$filter=name eq '${name}'`;
    const result = await (0, node_1.retrieveMultiple)(apiConfig, 'webresourceset', options);
    return result.value.length > 0 ? result.value[0].webresourceid : '';
}
async function createResource(resource, content, apiConfig) {
    logger_1.logger.info(`create web resource ${resource.name}`);
    const webResource = {
        webresourcetype: getWebResourceType(resource.type),
        name: resource.name,
        displayname: resource.displayname || resource.name,
        content: content
    };
    const result = await (0, node_1.createWithReturnData)(apiConfig, 'webresourceset', webResource, '$select=webresourceid');
    if (result.error) {
        throw new Error(result.error.message);
    }
    return result.webresourceid;
}
async function updateResource(id, resource, content, apiConfig) {
    logger_1.logger.info(`update web resource ${resource.name}`);
    const webResource = {
        content: content
    };
    await (0, node_1.update)(apiConfig, 'webresourceset', id, webResource);
    return `<webresource>{${id}}</webresource>`;
}
