"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
const fs_1 = __importDefault(require("fs"));
const glob_1 = __importDefault(require("glob"));
const node_1 = require("dataverse-webapi/lib/node");
const pluginType_1 = require("./pluginType");
const dataverse_service_1 = require("../dataverse.service");
const logger_1 = require("../logger");
async function deploy(config, apiConfig, solution) {
    const files = glob_1.default.sync(`**/${config.name}.dll`);
    if (files.length === 0) {
        logger_1.logger.warn(`assembly ${config.name}.dll not found`);
        return;
    }
    const content = (await fs_1.default.promises.readFile(files[0])).toString('base64');
    let assemblyId = '';
    try {
        assemblyId = await retrieveAssembly(config.name, apiConfig);
    }
    catch (error) {
        logger_1.logger.error(`failed to retrieve assembly ${config.name}: ${error.message}`);
        return;
    }
    if (assemblyId != '') {
        try {
            await updateAssembly(assemblyId, config, content, apiConfig);
        }
        catch (error) {
            throw new Error(`failed to update assembly: ${error.message}`);
        }
    }
    else {
        try {
            assemblyId = await createAssembly(config, content, apiConfig);
        }
        catch (error) {
            throw new Error(`failed to create assembly: ${error.message}`);
        }
        if (solution != undefined) {
            try {
                await (0, dataverse_service_1.addToSolution)(assemblyId, solution, dataverse_service_1.ComponentType.PluginAssembly, apiConfig);
            }
            catch (error) {
                logger_1.logger.error(`failed to add to solution: ${error.message}`);
            }
        }
    }
    if (config.types != null) {
        try {
            const promises = config.types.map(async (type) => {
                type['pluginassemblyid@odata.bind'] = `/pluginassemblies(${assemblyId})`;
                await (0, pluginType_1.deployType)(type, assemblyId, apiConfig, solution);
            });
            await Promise.all(promises);
        }
        catch (error) {
            logger_1.logger.error(error.message);
            return;
        }
    }
}
exports.deploy = deploy;
async function retrieveAssembly(name, apiConfig) {
    const options = `$select=pluginassemblyid&$filter=name eq '${name}'`;
    const result = await (0, node_1.retrieveMultiple)(apiConfig, 'pluginassemblies', options);
    return result.value.length > 0 ? result.value[0].pluginassemblyid : '';
}
async function createAssembly(config, content, apiConfig) {
    logger_1.logger.info(`create assembly ${config.name}`);
    const assembly = {
        name: config.name,
        content: content,
        isolationmode: config.isolationmode,
        version: config.version,
        publickeytoken: config.name,
        sourcetype: 0,
        culture: ''
    };
    const result = await (0, node_1.createWithReturnData)(apiConfig, 'pluginassemblies', assembly, '$select=pluginassemblyid');
    if (result.error) {
        throw new Error(result.error.message);
    }
    return result.pluginassemblyid;
}
async function updateAssembly(id, config, content, apiConfig) {
    logger_1.logger.info(`update assembly ${config.name}`);
    const assembly = {
        content: content,
        version: config.version
    };
    return (0, node_1.update)(apiConfig, 'pluginassemblies', id, assembly);
}
