"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const prompts_1 = __importDefault(require("prompts"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const logger_1 = require("./logger");
const assemblyDeploy_1 = require("./assemblyDeploy");
const webResourceDeploy_1 = require("./webResourceDeploy");
const node_1 = require("dataverse-webapi/lib/node");
const auth_1 = require("./auth");
const cachePlugin_1 = require("./cachePlugin");
const onTokenFailure = async (url, error) => {
    if (error) {
        logger_1.logger.error(`failed to acquire access token: ${error}`);
    }
    else {
        logger_1.logger.error('failed to acquire access token');
    }
    if ((0, cachePlugin_1.cacheExists)(url)) {
        const { deleteToken } = await (0, prompts_1.default)({
            type: 'confirm',
            name: 'deleteToken',
            message: `delete current token cache for ${url}?`
        });
        if (deleteToken) {
            (0, cachePlugin_1.deleteCache)(url);
        }
    }
};
async function deploy(type, files) {
    if (!type || (type !== 'webresource' && type !== 'assembly')) {
        const invalid = type !== undefined && type !== 'webresource' && type !== 'assembly';
        const invalidMessage = invalid ? `${type} is not a valid project type.` : '';
        const { typePrompt } = await (0, prompts_1.default)({
            type: 'select',
            name: 'typePrompt',
            message: `${invalidMessage} select project type to deploy`,
            choices: [
                { title: 'web resource', value: 'webresource' },
                { title: 'plugin or workflow activity', value: 'assembly' }
            ]
        });
        type = typePrompt;
    }
    const currentPath = '.';
    const credsFile = await fs_1.default.promises.readFile(path_1.default.resolve(currentPath, 'dataverse.config.json'), 'utf8');
    if (credsFile == null) {
        logger_1.logger.warn('unable to find dataverse.config.json file');
        return;
    }
    const creds = JSON.parse(credsFile).connection;
    let token = null;
    try {
        token = await (0, auth_1.getAccessToken)(creds.tenant, creds.server);
    }
    catch (error) {
        onTokenFailure(creds.server, error.message);
        return;
    }
    if (token == null || token.accessToken == null) {
        onTokenFailure(creds.server);
        return;
    }
    const apiConfig = new node_1.WebApiConfig('8.2', token.accessToken, creds.server);
    switch (type) {
        case 'webresource':
            await (0, webResourceDeploy_1.deployWebResource)(creds, apiConfig, files);
            break;
        case 'assembly':
            await (0, assemblyDeploy_1.deployAssembly)(creds, apiConfig);
            break;
        default:
            break;
    }
}
exports.default = deploy;
