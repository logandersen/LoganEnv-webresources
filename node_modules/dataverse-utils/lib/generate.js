"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const prompts_1 = __importDefault(require("prompts"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const logger_1 = require("./logger");
const dataverse_service_1 = require("./dataverse.service");
const node_1 = require("dataverse-webapi/lib/node");
const auth_1 = require("./auth");
async function generate(table) {
    while (!table) {
        const { tablePrompt } = await (0, prompts_1.default)({
            type: 'text',
            name: 'tablePrompt',
            message: `enter table to generate`
        });
        table = tablePrompt;
    }
    const currentPath = '.';
    const credsFile = await fs_1.default.promises.readFile(path_1.default.resolve(currentPath, 'dataverse.config.json'), 'utf8');
    if (credsFile == null) {
        logger_1.logger.warn('unable to find dataverse.config.json file');
        return;
    }
    const creds = JSON.parse(credsFile).connection;
    let token = null;
    try {
        token = await (0, auth_1.getAccessToken)(creds.tenant, creds.server);
    }
    catch (error) {
        logger_1.logger.error(`failed to acquire access token: ${error.message}`);
        return;
    }
    if (token == null || token.accessToken == null) {
        logger_1.logger.error('failed to acquire access token');
        return;
    }
    const apiConfig = new node_1.WebApiConfig('8.2', token.accessToken, creds.server);
    let metadata = {};
    logger_1.logger.info('Retrieve table metadata');
    try {
        metadata = await (0, dataverse_service_1.getTableMetadata)(table, apiConfig);
    }
    catch (error) {
        logger_1.logger.error(error.message);
        return;
    }
    // Build code file from metadata
    const codeFile = [
        `class ${metadata.schemaName} {`,
        '\r\n',
        `  LogicalName = '${metadata.logicalName}';`,
        '\r\n',
        `  SchemaName = '${metadata.schemaName}';`,
        '\r\n',
        `  EntitySetName = '${metadata.entitySetName}';`,
        '\r\n',
        '\r\n',
        '  Fields = {',
        '\r\n',
        metadata.fields.map(f => {
            return `    '${f.schemaName}': '${f.logicalName}'`;
        }).join(',\r\n'),
        '\r\n',
        '  }',
        '\r\n',
        '\r\n',
        metadata.choices.map(c => {
            const field = metadata.fields.find(f => f.logicalName === c.column);
            return `  ${field?.schemaName ?? c.column} = ${metadata.schemaName}_${field?.schemaName ?? c.column};`;
        }).join('\r\n'),
        '\r\n',
        '}',
        '\r\n',
        '\r\n',
        metadata.choices.map(c => {
            const field = metadata.fields.find(f => f.logicalName === c.column);
            return [
                `export enum ${metadata.schemaName}_${field?.schemaName ?? c.column} {`,
                '\r\n',
                c.options.map(x => `  '${x.text.replace(`'`, `\\'`)}' = ${x.value}`).join(',\r\n'),
                '\r\n',
                '}'
            ].join('');
        }).join('\r\n\r\n'),
        '\r\n',
        '\r\n',
        `export default new ${metadata.schemaName}();`
    ].join('');
    if (!fs_1.default.existsSync(path_1.default.resolve(currentPath, 'src', 'scripts', 'models'))) {
        fs_1.default.mkdirSync(path_1.default.resolve(currentPath, 'src', 'scripts', 'models'));
    }
    fs_1.default.writeFileSync(path_1.default.resolve(currentPath, 'src', 'scripts', 'models', `${metadata.schemaName}.ts`), codeFile);
    logger_1.logger.done(`Table metadata output to models/${metadata.schemaName}.ts`);
}
exports.default = generate;
