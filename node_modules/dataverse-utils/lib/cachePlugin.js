"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cachePlugin = exports.deleteCache = exports.cacheExists = exports.getCachePath = void 0;
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const cryptr_1 = __importDefault(require("cryptr"));
const encrypt = (text) => {
    const user = os_1.default.userInfo().username;
    const cryptr = new cryptr_1.default(user);
    const encrypted = cryptr.encrypt(text);
    return encrypted;
};
const decrypt = (text) => {
    const user = os_1.default.userInfo().username;
    const cryptr = new cryptr_1.default(user);
    const decrypted = cryptr.decrypt(text);
    return decrypted;
};
const getCachePath = (url) => {
    const org = url.replace('https://', '').split('.')[0];
    if (!fs_1.default.existsSync(path_1.default.join(os_1.default.homedir(), './.dataverse-utils/'))) {
        fs_1.default.mkdirSync(path_1.default.join(os_1.default.homedir(), './.dataverse-utils/'));
    }
    return path_1.default.join(os_1.default.homedir(), `./.dataverse-utils/${org}.json`);
};
exports.getCachePath = getCachePath;
const cacheExists = (url) => {
    const cacheLocation = (0, exports.getCachePath)(url);
    return fs_1.default.existsSync(cacheLocation);
};
exports.cacheExists = cacheExists;
const deleteCache = (url) => {
    const cacheLocation = (0, exports.getCachePath)(url);
    if (fs_1.default.existsSync(cacheLocation)) {
        fs_1.default.unlinkSync(cacheLocation);
        return true;
    }
    else {
        return false;
    }
};
exports.deleteCache = deleteCache;
const cachePlugin = (url) => {
    const cacheLocation = (0, exports.getCachePath)(url);
    const beforeCacheAccess = (tokenCacheContext) => {
        return new Promise((resolve, reject) => {
            if (fs_1.default.existsSync(cacheLocation)) {
                fs_1.default.readFile(cacheLocation, 'utf-8', (err, data) => {
                    if (err) {
                        reject();
                    }
                    else {
                        const decrypted = decrypt(data);
                        tokenCacheContext.tokenCache.deserialize(decrypted);
                        resolve();
                    }
                });
            }
            else {
                const encrypted = encrypt(tokenCacheContext.tokenCache.serialize());
                fs_1.default.writeFile(cacheLocation, encrypted, (err) => {
                    if (err) {
                        reject();
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    };
    const afterCacheAccess = (tokenCacheContext) => {
        return new Promise((resolve, reject) => {
            if (tokenCacheContext.cacheHasChanged) {
                const encrypted = encrypt(tokenCacheContext.tokenCache.serialize());
                fs_1.default.writeFile(cacheLocation, encrypted, (err) => {
                    if (err) {
                        reject(err);
                    }
                    resolve();
                });
            }
            else {
                resolve();
            }
        });
    };
    return {
        beforeCacheAccess,
        afterCacheAccess
    };
};
exports.cachePlugin = cachePlugin;
